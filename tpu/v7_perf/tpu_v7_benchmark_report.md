# TPU v7 (Ironwood) 单芯片 GEMM 性能测试报告

> 测试日期: 2026-02-10
> 测试工具: chay_gemm_benchmark_simple
> 测试人员: chrisya

---

## 1. 测试环境

| 项目 | 值 |
|------|------|
| **TPU 型号** | TPU7x (Ironwood) |
| **Pod 拓扑** | 2x2x1 (4 chips / 8 JAX devices) |
| **测试范围** | 单 chiplet (1 JAX device) |
| **JAX 版本** | 0.8.2.dev20251215 |
| **Pod 名称** | chrisya-sleep-inf-2x2x1-20260210-0539-slice-job-0-0-4zqln |
| **区域** | us-central1-ai1a |
| **GKE 集群** | XPK managed |

### 1.1 Ironwood 架构说明

TPU v7 (Ironwood) 采用 **Dual-Chiplet 架构**，与此前 TPU 代次有显著不同：

```
物理芯片 (1 chip)
├── Chiplet 0 (JAX Device 0)
│   ├── 1x TensorCore (MXU)
│   ├── 2x SparseCore
│   └── 96 GiB HBM
├── Chiplet 1 (JAX Device 1)
│   ├── 1x TensorCore (MXU)
│   ├── 2x SparseCore
│   └── 96 GiB HBM
└── Die-to-Die interconnect (6x ICI speed)
```

JAX 将每个 chiplet 暴露为独立设备，因此 4 个物理芯片在 JAX 中呈现为 **8 个设备**：

```
Device 0: TPU_0(process=0,(0,0,0,0))  ← Chip(0,0,0) Chiplet 0
Device 1: TPU_1(process=0,(0,0,0,1))  ← Chip(0,0,0) Chiplet 1
Device 2: TPU_2(process=0,(1,0,0,0))  ← Chip(1,0,0) Chiplet 0
Device 3: TPU_3(process=0,(1,0,0,1))  ← Chip(1,0,0) Chiplet 1
Device 4: TPU_4(process=0,(0,1,0,0))  ← Chip(0,1,0) Chiplet 0
Device 5: TPU_5(process=0,(0,1,0,1))  ← Chip(0,1,0) Chiplet 1
Device 6: TPU_6(process=0,(1,1,0,0))  ← Chip(1,1,0) Chiplet 0
Device 7: TPU_7(process=0,(1,1,0,1))  ← Chip(1,1,0) Chiplet 1
```

## 2. 硬件规格

### 2.1 官方规格 (Per Chip)

来源: [Google Cloud TPU7x 文档](https://docs.cloud.google.com/tpu/docs/tpu7x) (2026-02-09)

| 规格 | TPU v5p | TPU v6e (Trillium) | TPU v7 (Ironwood) | v7 vs v6e |
|------|---------|--------------------|--------------------|-----------|
| BF16 峰值 (TFLOPS) | 459 | 918 | **2,307** | **2.51x** |
| FP8 峰值 (TFLOPS) | 459* | 918* | **4,614** | **5.02x** |
| HBM 容量 (GiB) | 95 | 32 | **192** | **6.0x** |
| HBM 带宽 (GB/s) | 2,765 | 1,638 | **7,380** | **4.5x** |
| TensorCore 数量 | 2 | 1 | **2** | 2.0x |
| SparseCore 数量 | 4 | 2 | **4** | 2.0x |
| ICI 双向带宽 (GB/s) | 1,200 | 800 | **1,200** | 1.5x |

\* v5p 和 v6e 的 FP8 为模拟支持，v7 为原生支持。

### 2.2 Per-Chiplet 理论峰值 (本测试使用)

由于测试在单个 JAX device (= 1 chiplet) 上运行，MFU 计算基于 per-chiplet 峰值：

| 数据类型 | Per Chip | Per Chiplet (JAX Device) |
|----------|----------|--------------------------|
| BF16 | 2,307 TFLOPS | **1,153.5 TFLOPS** |
| FP16 | 2,307 TFLOPS | **1,153.5 TFLOPS** |
| FP32 | 2,307 TFLOPS | **1,153.5 TFLOPS** |
| INT8 | 4,614 TOPS | **2,307 TOPS** |
| HBM 带宽 | 7,380 GB/s | **3,690 GB/s** |
| HBM 容量 | 192 GiB | **96 GiB** |

> 注: FP32 与 BF16 峰值相同，因为 TPU MXU 使用 BF16 计算 + FP32 累加器实现 float32 GEMM。

---

## 3. 测试结果

### 3.1 BF16 (bfloat16) — TPU 原生精度

理论峰值: **1,153.5 TFLOPS** (per chiplet)

| M | N | K | 耗时 (μs) | TFLOPS | 带宽 (GB/s) | MFU |
|------|------|------|-----------|--------|-------------|------|
| 128 | 4096 | 4096 | 145.8 | 29.5 | 244.5 | 2.6% |
| 256 | 4096 | 4096 | 125.0 | 68.7 | 301.9 | 6.0% |
| 512 | 4096 | 4096 | 134.1 | 128.1 | 312.8 | 11.1% |
| 1024 | 4096 | 4096 | 152.6 | 225.2 | 329.9 | 19.5% |
| 2048 | 4096 | 4096 | 189.5 | 362.6 | 354.1 | 31.4% |
| 4096 | 4096 | 4096 | 296.2 | 464.1 | 339.9 | 40.2% |
| **8192** | **4096** | **4096** | **442.4** | **621.3** | **379.2** | **53.9%** |
| 128 | 8192 | 8192 | 191.8 | 89.6 | 721.7 | 7.8% |
| 256 | 8192 | 8192 | 170.5 | 201.5 | 836.3 | 17.5% |
| 512 | 8192 | 8192 | 196.6 | 349.6 | 768.1 | 30.3% |
| 1024 | 8192 | 8192 | 298.0 | 461.2 | 562.9 | 40.0% |
| 2048 | 8192 | 8192 | 446.1 | 616.1 | 451.3 | 53.4% |
| 4096 | 8192 | 8192 | 778.9 | 705.8 | 344.6 | 61.2% |
| **8192** | **8192** | **8192** | **1449.9** | **758.3** | **277.7** | **65.7%** |
| 128 | 4096 | 7168 | 171.0 | 43.9 | 360.2 | 3.8% |
| 256 | 4096 | 7168 | 167.3 | 89.9 | 385.6 | 7.8% |
| 512 | 4096 | 7168 | 194.8 | 154.3 | 360.7 | 13.4% |
| 1024 | 4096 | 7168 | 218.7 | 274.9 | 373.9 | 23.8% |
| 2048 | 4096 | 7168 | 312.7 | 384.6 | 335.3 | 33.3% |
| 4096 | 4096 | 7168 | 473.1 | 508.4 | 319.2 | 44.1% |
| 8192 | 4096 | 7168 | 703.0 | 684.2 | 346.0 | 59.3% |
| 128 | 7168 | 4096 | 135.4 | 55.5 | 455.0 | 4.8% |
| 256 | 7168 | 4096 | 141.1 | 106.5 | 456.9 | 9.2% |
| 512 | 7168 | 4096 | 168.8 | 178.1 | 416.1 | 15.4% |
| 1024 | 7168 | 4096 | 183.2 | 328.2 | 446.4 | 28.4% |
| 2048 | 7168 | 4096 | 273.8 | 439.2 | 383.0 | 38.1% |
| 4096 | 7168 | 4096 | 413.4 | 581.9 | 365.3 | 50.4% |
| 8192 | 7168 | 4096 | 686.2 | 701.0 | 354.5 | 60.8% |

**BF16 摘要:**

| 指标 | 值 |
|------|------|
| 最高 TFLOPS | **758.3** (M=8192, K=N=8192) |
| 最高 MFU | **65.7%** (M=8192, K=N=8192) |
| 平均 MFU | 29.8% |
| 最高带宽 | 836.3 GB/s (M=256, K=N=8192) |

### 3.2 FP32 (float32)

理论峰值: **1,153.5 TFLOPS** (per chiplet, bf16 compute path)

| M | N | K | 耗时 (μs) | TFLOPS | 带宽 (GB/s) | MFU |
|------|------|------|-----------|--------|-------------|------|
| 128 | 4096 | 4096 | 167.1 | 25.7 | 426.7 | 2.2% |
| 256 | 4096 | 4096 | 167.7 | 51.2 | 450.2 | 4.4% |
| 512 | 4096 | 4096 | 189.1 | 90.8 | 443.6 | 7.9% |
| 1024 | 4096 | 4096 | 207.1 | 165.9 | 486.1 | 14.4% |
| 2048 | 4096 | 4096 | 249.3 | 275.6 | 538.4 | 23.9% |
| 4096 | 4096 | 4096 | 391.5 | 351.1 | 514.2 | 30.4% |
| 8192 | 4096 | 4096 | 581.5 | 472.7 | 577.0 | 41.0% |
| 128 | 8192 | 8192 | 246.4 | 69.7 | 1123.6 | 6.0% |
| 256 | 8192 | 8192 | 244.4 | 140.6 | 1166.9 | 12.2% |
| 512 | 8192 | 8192 | 290.8 | 236.3 | 1038.6 | 20.5% |
| 1024 | 8192 | 8192 | 353.8 | 388.5 | 948.4 | 33.7% |
| 2048 | 8192 | 8192 | 555.7 | 494.6 | 724.6 | 42.9% |
| 4096 | 8192 | 8192 | 926.2 | 593.5 | 579.6 | 51.5% |
| **8192** | **8192** | **8192** | **1638.8** | **670.9** | **491.4** | **58.2%** |
| 128 | 4096 | 7168 | 151.6 | 49.6 | 812.8 | 4.3% |
| 256 | 4096 | 7168 | 154.2 | 97.5 | 836.6 | 8.5% |
| 512 | 4096 | 7168 | 164.4 | 182.9 | 854.7 | 15.9% |
| 1024 | 4096 | 7168 | 197.9 | 303.8 | 826.4 | 26.3% |
| 2048 | 4096 | 7168 | 325.9 | 369.0 | 643.5 | 32.0% |
| 4096 | 4096 | 7168 | 518.0 | 464.3 | 582.9 | 40.2% |
| 8192 | 4096 | 7168 | 865.5 | 555.8 | 562.1 | 48.2% |
| 128 | 7168 | 4096 | 165.6 | 45.4 | 744.0 | 3.9% |
| 256 | 7168 | 4096 | 154.7 | 97.1 | 833.4 | 8.4% |
| 512 | 7168 | 4096 | 168.7 | 178.2 | 833.0 | 15.5% |
| 1024 | 7168 | 4096 | 196.6 | 305.8 | 831.8 | 26.5% |
| 2048 | 7168 | 4096 | 288.8 | 416.3 | 726.0 | 36.1% |
| 4096 | 7168 | 4096 | 521.8 | 460.9 | 578.7 | 40.0% |
| 8192 | 7168 | 4096 | 843.3 | 570.4 | 576.9 | 49.4% |

**FP32 摘要:**

| 指标 | 值 |
|------|------|
| 最高 TFLOPS | **670.9** (M=8192, K=N=8192) |
| 最高 MFU | **58.2%** (M=8192, K=N=8192) |
| 平均 MFU | 25.2% |
| 最高带宽 | 1166.9 GB/s (M=256, K=N=8192) |

### 3.3 INT8

理论峰值: **2,307 TOPS** (per chiplet)

| M | N | K | 耗时 (μs) | TFLOPS | 带宽 (GB/s) | MFU |
|------|------|------|-----------|--------|-------------|------|
| 128 | 4096 | 4096 | 168.1 | 25.6 | 115.4 | 1.1% |
| 256 | 4096 | 4096 | 126.8 | 67.7 | 173.6 | 2.9% |
| 512 | 4096 | 4096 | 137.1 | 125.3 | 198.8 | 5.4% |
| 1024 | 4096 | 4096 | 157.8 | 217.7 | 239.2 | 9.4% |
| 2048 | 4096 | 4096 | 214.6 | 320.2 | 273.6 | 13.9% |
| 4096 | 4096 | 4096 | 309.8 | 443.7 | 325.0 | 19.2% |
| 8192 | 4096 | 4096 | 484.0 | 567.9 | 381.3 | 24.6% |
| 128 | 8192 | 8192 | 155.9 | 110.2 | 464.1 | 4.8% |
| 256 | 8192 | 8192 | 165.8 | 207.2 | 468.0 | 9.0% |
| 512 | 8192 | 8192 | 244.9 | 280.6 | 359.7 | 12.2% |
| 1024 | 8192 | 8192 | 360.3 | 381.5 | 302.7 | 16.5% |
| 2048 | 8192 | 8192 | 500.1 | 549.7 | 301.9 | 23.8% |
| 4096 | 8192 | 8192 | 799.1 | 688.0 | 294.0 | 29.8% |
| **8192** | **8192** | **8192** | **1544.5** | **711.9** | **260.7** | **30.9%** |
| 128 | 4096 | 7168 | 160.3 | 46.9 | 202.0 | 2.0% |
| 256 | 4096 | 7168 | 171.3 | 87.7 | 206.5 | 3.8% |
| 512 | 4096 | 7168 | 194.8 | 154.3 | 212.6 | 6.7% |
| 1024 | 4096 | 7168 | 240.5 | 250.0 | 222.4 | 10.8% |
| 2048 | 4096 | 7168 | 336.5 | 357.4 | 230.6 | 15.5% |
| 4096 | 4096 | 7168 | 475.9 | 505.4 | 264.4 | 21.9% |
| 8192 | 4096 | 7168 | 741.4 | 648.8 | 299.8 | 28.1% |
| 128 | 7168 | 4096 | 154.6 | 48.6 | 217.0 | 2.1% |
| 256 | 7168 | 4096 | 172.9 | 87.0 | 218.4 | 3.8% |
| 512 | 7168 | 4096 | 178.8 | 168.1 | 258.0 | 7.3% |
| 1024 | 7168 | 4096 | 229.5 | 262.0 | 274.2 | 11.4% |
| 2048 | 7168 | 4096 | 320.5 | 375.2 | 301.0 | 16.3% |
| 4096 | 7168 | 4096 | 480.9 | 500.2 | 340.2 | 21.7% |
| 8192 | 7168 | 4096 | 760.5 | 632.5 | 391.6 | 27.4% |

**INT8 摘要:**

| 指标 | 值 |
|------|------|
| 最高 TOPS | **711.9** (M=8192, K=N=8192) |
| 最高 MFU | **30.9%** (M=8192, K=N=8192) |
| 平均 MFU | 13.7% |
| 最高带宽 | 468.0 GB/s (M=256, K=N=8192) |

---

## 4. 跨代对比分析: TPU v7 vs TPU v6e

### 4.1 峰值性能对比

| 指标 | v6e (Trillium) | v7 (Ironwood) chiplet | v7 vs v6e | v7 整芯片 |
|------|----------------|----------------------|-----------|-----------|
| **BF16 最高 TFLOPS** | 689.0 | 758.3 | **1.10x** | ~1516.6 |
| **BF16 最高 MFU** | 75.0% | 65.7% | 0.88x | — |
| **FP32 最高 TFLOPS** | 583.0 | 670.9 | **1.15x** | ~1341.8 |
| **FP32 最高 MFU** | 63.5% | 58.2% | 0.92x | — |
| **INT8 最高 TOPS** | 1129.0 | 711.9 | 0.63x | ~1423.8 |
| **INT8 最高 MFU** | 61.5% | 30.9% | 0.50x | — |

### 4.2 相同矩阵维度对比 (M=8192, K=N=8192)

| 数据类型 | v6e TFLOPS | v7 chiplet TFLOPS | 实际加速比 | 理论加速比 |
|----------|------------|-------------------|------------|------------|
| BF16 | 668.1 | 758.3 | **1.13x** | 1.26x (1153.5/918) |
| FP32 | 361.2 | 670.9 | **1.86x** | 1.26x |
| INT8 | 1129.0 | 711.9 | **0.63x** | 1.26x (2307/1836) |

### 4.3 相同矩阵维度对比 (M=4096, K=N=8192)

| 数据类型 | v6e TFLOPS | v7 chiplet TFLOPS | 实际加速比 |
|----------|------------|-------------------|------------|
| BF16 | 688.9 | 705.8 | 1.02x |
| FP32 | 356.9 | 593.5 | **1.66x** |
| INT8 | 1018.7 | 688.0 | 0.68x |

### 4.4 关键观察

#### BF16 性能

- v7 单 chiplet 的 **绝对 TFLOPS** 超越了 v6e 整芯片（758 vs 689），说明单个 chiplet 的计算能力已经超过 v6e 整芯片
- **MFU 较低** (65.7% vs 75.0%)，说明 v7 的 MXU 吞吐提升幅度 (2.51x) 大于内存带宽提升 (4.5x)，但在当前矩阵尺寸下仍未充分利用计算单元
- v7 chiplet MFU 天花板可能需要**更大的矩阵维度**才能触达

#### FP32 性能

- v7 的 FP32 表现**显著优于** v6e (670.9 vs 361.2 TFLOPS, 1.86x)
- v6e 在大矩阵 FP32 上出现异常退化 (M=4096/8192 时 MFU 仅 38-39%)，而 v7 保持了稳健的 MFU 增长
- 这表明 v7 在 BF16+FP32累加路径上的优化更加成熟

#### INT8 性能

- v7 chiplet 的 INT8 实测 TFLOPS **低于** v6e (711.9 vs 1129.0)
- 这是一个**异常发现**，可能原因:
  1. **JAX dev 版本对 v7 INT8 路径优化不足** — JAX 0.8.2.dev 可能尚未完全优化 v7 的原生 INT8/FP8 指令
  2. **MXU 架构差异** — v7 的 dual-chiplet 可能在 INT8 数据搬运上有额外开销
  3. **INT8 compute-bound** — v7 理论 INT8 峰值极高 (2307 TOPS/chiplet)，当前矩阵规模不足以填满流水线
- 建议: 使用更大矩阵 (M=16384+) 重新测试，或等待 JAX stable 版本

---

## 5. 性能特征深度分析

### 5.1 MFU 与矩阵维度 M 的关系

```
BF16 MFU vs M (K=N=8192):

M=128  ▏██                                        7.8%
M=256  ▏████                                     17.5%
M=512  ▏███████                                  30.3%
M=1024 ▏██████████                               40.0%
M=2048 ▏█████████████                            53.4%
M=4096 ▏███████████████                          61.2%
M=8192 ▏████████████████                         65.7%
       └─────────────────────────────────── 100%
```

**规律**: MFU 随 M 增大单调递增，但增速在 M > 4096 后放缓。这表明:
- M < 512: 严重 memory-bound，MXU 流水线填充不足
- 512 ≤ M < 4096: compute 和 memory 混合瓶颈
- M ≥ 4096: 逐步接近 compute-bound，但带宽仍是限制因素

### 5.2 带宽利用率分析

| 数据类型 | 最高带宽 | per-chiplet 理论带宽 | 带宽利用率 |
|----------|----------|---------------------|------------|
| BF16 | 836.3 GB/s | 3,690 GB/s | **22.7%** |
| FP32 | 1166.9 GB/s | 3,690 GB/s | **31.6%** |
| INT8 | 468.0 GB/s | 3,690 GB/s | **12.7%** |

HBM 带宽利用率相对较低，说明当前测试矩阵规模下，瓶颈主要在**计算端**而非内存端。v7 的 HBM 带宽提升 (4.5x vs v6e) 为更大规模模型推理提供了充足的带宽余量。

### 5.3 Arithmetic Intensity 分析

GEMM 的算术强度 (Arithmetic Intensity) = 2MNK / (2MK + 2KN + elem_size × MN):

| M | K=N | AI (BF16) | AI (FP32) | 瓶颈类型 |
|------|------|-----------|-----------|----------|
| 128 | 8192 | ~128 | ~85 | Memory-bound |
| 512 | 8192 | ~480 | ~320 | 过渡区 |
| 2048 | 8192 | ~1639 | ~1092 | Compute-bound |
| 8192 | 8192 | ~4096 | ~2731 | Compute-bound |

v7 chiplet 的 compute-to-bandwidth ratio = 1153.5 TFLOPS / 3.69 TB/s ≈ **312.6 FLOP/Byte**。
要达到计算瓶颈，需要 AI > 312.6，对应 M > 512 (K=N=8192)。实测数据与此理论预测一致。

---

## 6. 总结

### 6.1 核心结论

| # | 结论 |
|---|------|
| 1 | v7 单 chiplet BF16 最高 **758.3 TFLOPS** (MFU 65.7%)，绝对性能超越 v6e 整芯片 |
| 2 | v7 整芯片 (2 chiplets) 等效 BF16 约 **~1516 TFLOPS**，是 v6e 的 **2.2x** |
| 3 | FP32 性能提升显著 (**1.86x** vs v6e)，v7 的 BF16+FP32累加路径更成熟 |
| 4 | INT8 性能低于预期，可能受 JAX dev 版本限制，需后续验证 |
| 5 | HBM 带宽利用率较低 (~23-32%)，v7 带宽余量充足 |
| 6 | Dual-chiplet 架构对 benchmark 影响需关注：per-chiplet 峰值是 per-chip 的一半 |

### 6.2 建议后续测试

1. **更大矩阵维度**: M=16384, 32768 以探索更高 MFU
2. **FP8 测试**: v7 原生支持 FP8，是关键推理精度
3. **跨 chiplet GEMM**: 利用 D2D 互连在两个 chiplet 间分布计算
4. **多芯片并行**: 使用 pjit/sharding 测试多芯片 GEMM 性能
5. **JAX stable 版本**: 使用正式版 JAX 重新测试，排除 dev 版本的性能限制
6. **Pallas Kernel**: 使用 Pallas 自定义 kernel 可能获得更高 MFU

### 6.3 推荐配置

对于 TPU v7 (Ironwood) 上的 LLM 推理工作负载:

| 场景 | 推荐精度 | 推荐 batch size (M) | 预期 MFU |
|------|---------|---------------------|----------|
| 预填充 (Prefill) | BF16 | ≥ 4096 | 50-65% |
| 解码 (Decode) | BF16 | ≥ 512 | 20-30% |
| 大规模推理 | INT8/FP8 | ≥ 8192 | 待优化 |

---

## 附录

### A. 测试配置

```json
{
    "benchmark_settings": {
        "warmup_iter": 10,
        "prof_iter": 100
    },
    "cases": [{
        "dtype": ["bfloat16", "float32", "int8"],
        "K.N": [[4096, 4096], [8192, 8192], [7168, 4096], [4096, 7168]],
        "M": [128, 256, 512, 1024, 2048, 4096, 8192]
    }]
}
```

### B. 代码变更

本次测试涉及以下代码修改以支持 TPU v7:

1. **`backends/tpu/tpu_backends.py`** — 完整实现 `TpuV7Backend`，包含官方规格、dual-chiplet 感知、多策略检测逻辑
2. **`backends/tpu/trace_utils.py`** — Trace-based timing 工具，从 JAX profiler trace 提取纯设备执行时间
3. **`hw_spec.py`** — 更新 v7 per-chiplet 硬件规格
4. **`auto_benchmark.py`** — 更新 v7 per-chiplet 硬件规格
5. **`results_v7.csv`** — 完整原始测试数据

### B2. Trace-Based Timing 优化 (2026-02-11)

为提高 MFU 测量精度，新增 Trace-based timing 模式：

**问题背景：**
- 原有方法使用 `time.perf_counter()` 测量端到端时间
- 该时间包含 Python dispatch overhead、JAX async dispatch 等开销
- 导致测得的 MFU 偏低（~65-75%）

**解决方案：**
- 使用 JAX profiler trace 提取纯设备执行时间 `device_duration_ps`
- 该时间是 TPU 硬件级别的计时，排除所有 host 端开销
- 可获得 90%+ MFU（compute-bound workload）

**核心技术：**
```python
# 使用 jax.named_scope() 标记 GEMM 操作
with jax.profiler.trace(trace_dir):
    with jax.named_scope("!!MARKER!!"):
        result = gemm(a, b)
        result.block_until_ready()

# 从 trace 的 device_duration_ps 字段提取纯设备执行时间
trace = get_trace(trace_dir)
durations_ms = get_metrics_from_trace_marker(trace, "!!MARKER!!")
```

**使用方式：**
```bash
# 默认使用 trace 模式（推荐）
python main_tpu.py --config config/tpu_trace_test.json

# 对比：使用传统计时模式
python main_tpu.py --config config/tpu_trace_test.json --no-trace
```

**新增文件：**
- `backends/tpu/trace_utils.py` — Trace 解析工具
- `config/tpu_trace_test.json` — 快速验证配置

### C. 参考资料

- [Google Cloud TPU7x 文档](https://docs.cloud.google.com/tpu/docs/tpu7x)
- [Ironwood 发布博客](https://blog.google/innovation-and-ai/infrastructure-and-cloud/google-cloud/ironwood-tpu-age-of-inference/)
- [TPU 系统架构](https://docs.cloud.google.com/tpu/docs/system-architecture-tpu-vm)

---

*报告由 chay_gemm_benchmark_simple 自动化基准测试工具生成*
*Generated: 2026-02-10*
